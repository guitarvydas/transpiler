      pass1_semantics.addOperation(
	  'unity',
	  {
	      Program: function(tree) {return toSpaceDelimitedList(tree.unity())},
	      Form: function(item) {return item.unity()},
	      QuotedSexp: function(_, form) {return "'" + form.unity()},
	      BackQuotedSexp: function(_, form) {return "`" + form.unity()},
	      CommaSexp: function(_, form) {return "," + form.unity()},
	      SList: function(lis) {return lis.unity()},
	      DottedList: function(_lp, items, _dot, lastItem, _rp) {
		  return "(" + toSpaceDelimitedList(items.unity()) + " . " + lastItem.unity() + ")"},
	      NullTerminatedList: function(_lp, items, _rp) {
		  return "(" + toSpaceDelimitedList(items.unity()) + ")"},
	      ListItem: function(item) {return item.unity()},
	      Atom: function(a) {return a.unity()},
	      lexical_integer: function(ns) {return toPackedString(ns.unity());},
	      lexical_symbol: function(c, cs) {return c.unity() + toPackedString(cs.unity());},
	      lexical_string: function(_q1, chars, _q2) {return "\"" + toPackedString(chars.unity()) + "\""},
	      lexical_letchar: function(c) {return c.unity()},
	      lexical_numchar: function(c) {return c.unity()},
	      lexical_lc: function(c) {return c.unity()},
	      lexical_uc: function(c) {return c.unity()},

	      lexical_boolean: function(b) {return this.sourceString},
	      _terminal: function() { return this.primitiveValue; }
	  }
      );
      

          pass1_semantics.addOperation(
	  'unquote',
	  {
	      Program: function(tree) {return toSpaceDelimitedList(tree.unquote())},
	      Form: function(item) {return item.unquote()},
	      QuotedSexp: function(_, form) {return "(quote " + form.unquote() + ")"},
	      BackQuotedSexp: function(_, form) {return "`" + form.unquote()},
	      CommaSexp: function(_, form) {return "," + form.unquote()},
	      SList: function(lis) {return lis.unquote()},
	      DottedList: function(_lp, items, _dot, lastItem, _rp) {
		  return "(" + toSpaceDelimitedList(items.unquote()) + " . " + lastItem.unquote() + ")"},
	      NullTerminatedList: function(_lp, items, _rp) {
		  return "(" + toSpaceDelimitedList(items.unquote()) + ")"},
	      ListItem: function(item) {return item.unquote()},
	      Atom: function(a) {return a.unquote()},
	      lexical_integer: function(ns) {return toPackedString(ns.unquote());},
	      lexical_symbol: function(c, cs) {return c.unquote() + toPackedString(cs.unquote());},
	      lexical_string: function(_q1, chars, _q2) {return "\"" + toPackedString(chars.unquote()) + "\""},
	      lexical_letchar: function(c) {return c.unquote()},
	      lexical_numchar: function(c) {return c.unquote()},
	      lexical_lc: function(c) {return c.unquote()},
	      lexical_uc: function(c) {return c.unquote()},

	      lexical_boolean: function(b) {return this.sourceString},
	      _terminal: function() { return this.primitiveValue; }
	  }
      );

          pass1_semantics.addOperation(
	  'unbackquote',
	  {
	      Program: function(tree) {return toSpaceDelimitedList(tree.unbackquote())},
	      Form: function(item) {return item.unbackquote()},
	      QuotedSexp: function(_, form) {return "(quote " + form.unbackquote() + ")"},
	      BackQuotedSexp: function(_, form) {return form.inbackquote();},
	      CommaSexp: function(_, form) {throw "can\'t happen - comma not inside backquote - (actually, not necessarily the case, but nested backquotes left as an exercise for the reader)"},
	      SList: function(lis) {return lis.unbackquote()},
	      DottedList: function(_lp, items, _dot, lastItem, _rp) {
		  return "(" + toSpaceDelimitedList(items.unbackquote()) + " . " + lastItem.unbackquote() + ")"},
	      NullTerminatedList: function(_lp, items, _rp) {
		  return "(" + toSpaceDelimitedList(items.unbackquote()) + ")"},
	      ListItem: function(item) {return item.unbackquote()},
	      Atom: function(a) {return a.unbackquote()},
	      lexical_integer: function(ns) {return toPackedString(ns.unbackquote());},
	      lexical_symbol: function(c, cs) {return c.unbackquote() + toPackedString(cs.unbackquote());},
	      lexical_string: function(_q1, chars, _q2) {return "\"" + toPackedString(chars.unbackquote()) + "\""},
	      lexical_letchar: function(c) {return c.unbackquote()},
	      lexical_numchar: function(c) {return c.unbackquote()},
	      lexical_lc: function(c) {return c.unbackquote()},
	      lexical_uc: function(c) {return c.unbackquote()},

	      lexical_boolean: function(b) {return this.sourceString},
	      _terminal: function() { return this.primitiveValue; }
	  }
      );
      
          pass1_semantics.addOperation(
	  'inbackquote',
	  {
	      Program: function(tree) {throw "can\'t happen"},
	      Form: function(item) {return item.inbackquote()},
	      QuotedSexp: function(_, form) {return "(quote " + form.inbackquote() + ")"},
	      BackQuotedSexp: function(_, form) {throw "can\'t happen - left as exercise to the reader";},
	      CommaSexp: function(_, form) {return form.unity()}, // use unbackquote to get eval'ed value
	      SList: function(lis) {return lis.inbackquote()},
	      DottedList: function(_lp, items, _dot, lastItem, _rp) {
		  return "(list " + toSpaceDelimitedList(items.inbackquote()) + " . " + lastItem.inbackquote() + ")"},
	      NullTerminatedList: function(_lp, items, _rp) {
		  return "(list " + toSpaceDelimitedList(items.inbackquote()) + ")"},
	      ListItem: function(item) {return item.inbackquote()},
	      Atom: function(a) {return a.inbackquote()},
	      lexical_integer: function(ns) {return toPackedString(ns.inbackquote());},
	      lexical_symbol: function(c, cs) {return "(quote " + c.inbackquote() + toPackedString(cs.inbackquote()) + ")";},
	      lexical_string: function(_q1, chars, _q2) {return "\"" + toPackedString(chars.inbackquote()) + "\""},
	      lexical_letchar: function(c) {return c.inbackquote()},
	      lexical_numchar: function(c) {return c.inbackquote()},
	      lexical_lc: function(c) {return c.inbackquote()},
	      lexical_uc: function(c) {return c.inbackquote()},

	      lexical_boolean: function(b) {return this.sourceString},
	      _terminal: function() { return this.primitiveValue; }
	  }
      );
