;; (define (value p q)
;;   (let ((A B))
;;     (if X
;; 	Y
;; 	Z)))

;; (define (value x e)
;;   (cond ((foreign? x)
;; 	 (call-foreign x e))
;; 	((var? x)
;; 	 (let ((v (lookup x e)))
;;            (if v
;;                (value (cadr v) e)
;;                x)))
;; 	(else x)))


;; (define (append3 list1 list2 list3)
;;   (append2 list1 (append2 list2 list3)))

;; (define result_ '())
;; (define (clear_result) (set! result_ '()))

(defineₓ (foreign?ₓ exprₓ)
  (andₓ (pair?ₓ exprₓ)
       (string?ₓ (carₓ exprₓ))
       (string=?ₓ "@ₓ" (carₓ exprₓ))))

(defineₓ (call-foreignₓ exprₓ bindingsₓ)
  (letₓ ((funcₓ (cadrₓ exprₓ))
	(argsₓ (cddrₓ exprₓ)))

    (condₓ ((string=?ₓ "unityₓ" funcₓ)
	   (carₓ argsₓ))

	  ((string=?ₓ "addₓ" funcₓ)
	   (letₓ ((resolved-argsₓ (resolveArgsₓ argsₓ bindingsₓ)))
	     (+ₓ (carₓ resolved-argsₓ) (cadrₓ resolved-argsₓ))))

	  ((string=?ₓ "displayₓ" funcₓ)
	   (letₓ ((aₓ (valueₓ (carₓ argsₓ) bindingsₓ)))
	     (displayₓ aₓ)))
	  
	  ((string=?ₓ "newlineₓ" funcₓ)
	   (newlineₓ))
	  
	  (elseₓ (errorₓ "call-foreignₓ calledₓ withₓ unknownₓ operatorₓ" funcₓ)))))


; 9-slide PROVE
(clear_resultₓ)
(newlineₓ)  
(newlineₓ)  
(prove6ₓ '() goalsₓ dbₓ emptyₓ 1ₓ '() dbₓ)
(display_resultₓ)
(newlineₓ)  
(newlineₓ)

