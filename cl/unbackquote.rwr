{
    Program: function(tree) {return toSpaceDelimitedList(tree.unbackquote())},
    Form: function(item) {return item.unbackquote()},
    QuotedSexp: function(_, form) {return "(quote " + form.unbackquote() + ")"},
    BackQuotedSexp: function(_, form) {return form.inbackquote();},
    CommaSexp: function(_, form) {throw "can\'t happen - comma not inside backquote - (actually, not necessarily the case, but nested backquotes left as an exercise for the reader)"},
    SList: function(lis) {return lis.unbackquote()},
    DottedList: function(_lp, items, _dot, lastItem, _rp) {
	return "(" + toSpaceDelimitedList(items.unbackquote()) + " . " + lastItem.unbackquote() + ")"},
    NullTerminatedList: function(_lp, items, _rp) {
	return "(" + toSpaceDelimitedList(items.unbackquote()) + ")"},
    ListItem: function(item) {return item.unbackquote()},
    Atom: function(a) {return a.unbackquote()},
    lexical_integer: function(ns) {return toPackedString(ns.unbackquote());},
    lexical_symbol: function(c, cs) {return c.unbackquote() + toPackedString(cs.unbackquote());},
    lexical_string: function(_q1, chars, _q2) {return "\"" + toPackedString(chars.unbackquote()) + "\""},
    lexical_letchar: function(c) {return c.unbackquote()},
    lexical_numchar: function(c) {return c.unbackquote()},
    lexical_lc: function(c) {return c.unbackquote()},
    lexical_uc: function(c) {return c.unbackquote()},
    
    lexical_boolean: function(b) {return this.sourceString},
    _terminal: function() { return this.primitiveValue; }
}
