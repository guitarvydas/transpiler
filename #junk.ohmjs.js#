#!/usr/bin/env node
//'use strict'

// Ohm-JS as a command-line command
//
// an Ohm-JS application consists of 2 operations in sequence
// 1. pattern match
// 2. if the pattern match was successful, then tree-walk the result and apply semantics

const fs = require ('fs');
const ohm = require ('ohm-js');

let argv;

function makeAST (grammarName, grammarText) {
    // returns an AST object or an error object
    // an AST is an Abstract Syntax Tree, which encodes ALL possible matches
    // in true OO fashion, the AST is further embellished with various methods and
    //  private data, then returned as an internal object
    // returns a triplet [success, ast, error if any]
    //
    // OhmJS converts the text for the grammar into an internal data structure,
    //  that internal data structure is needed for later operations
    // grammarName is used to select only one of the grammars, for matching
    // grammarText contains multiple grammars in textual format
    //
    // the use-case for multiple grammars is, most often, the fact that a grammar
    //  can inherit from other grammars, hence, a grammar text file can contain a number
    //  of uniquely named grammars, only one of which is meant to be used
    //
    let grammars = undefined;
    let ast = undefined;
    let emessage = '';
    try {
	grammars = ohm.grammars (grammarText);
	ast = grammars [grammarName];
	return [true, ast, undefined]
    } catch (e) {
	return [false, undefined, e];
    }
}

function patternMatch (src, ast) {
    // return a triplet { success, CST object, error message if any }
    //
    let matchResult;
    try {
	matchResult = ohmGrammarObject.match (src);
    } catch (err) {
	return [false, undefined, err.message];
    }
    if (matchResult.failed ()) {
	return [false, ohmGrammarObject, matchResult.message];
    } else { 
	console.log ("*** grammar object ***");
	console.log (ohmGrammarObject);
	console.log ("*** ***");

	console.log ("*** match result ***");
	console.log (matchResult);
	console.log ("*** ***");
	return [true, ohmGrammarObject, ""];
    }
}

function applySemantics (ohmGrammarObject, rwrFileName, supportFileName) {
    let semanticsFunctionsAsString;
    let evalableSemanticsFunctions;
    let ohmSemanticsObject;
    let compiledSemantics;
    try {
	semanticsFunctionsAsString = fs.readFileSync (rwrFileName, 'utf-8');
	let ohmSemanticsObject = ohmGrammarObject.createSemantics ();

	let evalableSemanticsFunctionsString = '(' + semanticsFunctionsAsString + ')';
	compiledSemantics = eval (evalableSemanticsFunctionsString);
	ohmSemanticsObject.addOperation ("walk", compiledSemantics);

	console.log ("*** semantics object ***");
	console.log (ohmSemanticsObject);
	console.log ("*** ***");

    } catch (e) {
	console.error (e.message);
	process.exit (1);
    }
}


/////


function main () {
    // top level command, prints on stdout and stderr (if error) then exits with 0 or 1 (OK, or not OK, resp.)
    try {
	argv = require('yargs/yargs')(process.argv.slice(2)).argv;

	let grammarName = argv._[0];
	let grammarFileName = argv._[1];
	let rwrFileName = argv._[2];
	let supportFileName = argv._[3];
	let src = fs.readFileSync ('/dev/fd/0', 'utf-8');

	let grammarText = fs.readFileSync (grammarFileName, 'utf-8');
	let rwr = fs.readFileSync (rwrFileName, 'utf-8');

	let r;
	[success, ast, e] = makeAST (grammarName, grammarText);
	if (!success) {
	    console.error (e.message);
	    process.exit (1);
	} else {
	    r = patternMatch (src, grammarName, grammar);
	    let success = r [0]
	    let ohmGrammarObject = r [1]
	    let errormessage = r [2]
	    if (success) {
		r = applySemantics (ohmGrammarObject, rwrFileName, supportFileName);
		process.exit (0);
	    } else {
		console.error (errormessage);
		process.exit (1);
	    }
	} else {
	    return [
    } catch (e) {
	console.error (e.message);
	process.exit (1);
    }
}

main ()
